# -*- coding: utf-8 -*-
import queue, threading, time, random, datetime

workers=[(0, u'Директор'),
         (1, u'Бухгалтер 1'),
         (1, u'Бухгалтер 2'),
         (50, u'Начальник IT отдела'),
         (60, u'Главный программист'),
         (70, u'Программист'),
         (75, u'Дизайнер'),
         (99, u'Уборщик')]

# Перемешиваем список сотрудников в случайном порядке
random.shuffle(workers)

def worker(queue):
    """
    основной код находится здесь.
    """
    while True:
        # получаем задание из очереди в виде кортежа (приоритет, должность)
        job = queue.get()
        # Выводим на экран информацию о начале обслуживания сотрудника
        print(job[1], datetime.datetime.now().strftime('%H:%M:%S'))
        # Шутки ради, предполагаем что приоритет явно связан с размером зарплаты и исходя из этого, затраченному времени на выдачу денег.
        time.sleep((100-job[0])/10)
        # Выводим информацию об окончании обслуживания сотрудника
        print(job[1], datetime.datetime.now().strftime('%H:%M:%S'))
        # Сообщаем что задание выполнено
        queue.task_done()

# Создаем приоритетную очередь и наполняем ее заданиями
q = queue.PriorityQueue()
for item in workers:
    q.put(item)

# Создаем 2 потока которые будут обслуживать очередь.
for i in range(2):
    # В окнструктор поткоа передаем функцию которую будет выполнять поток при вызове метода start(), а также последовательность аргументов которые будут переданы функции worker.
    t = threading.Thread(target=worker, args=(q,))
    t.setDaemon(True)
    t.start()

# Блокируем выполнение программы до выполнения всех заданий в очереди
q.join()